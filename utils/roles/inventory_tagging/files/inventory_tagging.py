#  Copyright 2024 Dell Inc. or its subsidiaries. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import os
import json
import sys
import logging
from typing import List, Tuple
import argparse
import commentedconfigparser

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class InventoryManager:
    """Inventory tagging module.
    Handles inventory updates and database interactions for nodes.
    """
    def __init__(self, inventory_filenames, vendors, inventory_dir_path, path_to_db_file):
        self.inventory_filenames = inventory_filenames
        self.vendors = vendors
        self.inventory_dir_path = os.path.abspath(inventory_dir_path)
        self.db_path = path_to_db_file

    def add_inventory_files(self) -> None:
        """
        Create inventory files based on the configured filenames.
        """
        inventory_header = "# This file is generated by omnia, and should not be edited\n"
        # Create the directory if it doesn't exist
        if not os.path.exists(self.inventory_dir_path):
            os.makedirs(self.inventory_dir_path, mode=0o644)  # Use directory permissions
        # Iterate over the inventory filenames
        for filename in self.inventory_filenames:
            file_path = os.path.join(self.inventory_dir_path, filename)
            file_path = os.path.abspath(file_path)
            with open(file_path, 'w', encoding='utf-8') as file:
                # Write the header to the file
                file.write(inventory_header)
                # Write the group name to the file
                group_name = f"[{filename}]\n"
                file.write(group_name)
                file.flush()

    def get_cluster_details_db(self) -> List[Tuple[str, str, str, str, str, str]]:
        """
        Retrieves the cluster details from the database.
        Returns:
            List[Tuple[str, str, str, str, str]]: A list of tuples containing the
            node, service tag, admin IP, CPU, and GPU of each node in the cluster.
        """
        if self.db_path:
            sys.path.insert(0, self.db_path)
            try:
                # pylint: disable=C0415
                from omniadb_connection import create_connection
            except ImportError:
                logger.error("Failed to import omniadb_connection module from db_path: %s",
                             self.db_path)
                return []
            with create_connection() as conn:
                cursor = conn.cursor()
                query = """
                    SELECT
                        node,
                        service_tag,
                        hostname,
                        admin_ip,
                        cpu,
                        gpu
                    FROM
                        cluster.nodeinfo
                    WHERE
                        status = 'booted'
                """
                cursor.execute(query)
                nodes_info = cursor.fetchall()
                return nodes_info
        else:
            logger.error("The value is missing for db_path: %s", self.db_path)
            return []

    def add_hostname_inventory(self, inventory_file: str, hostname: str) -> None:
        """
        Adds a hostname to the inventory file, if does not exist.
        Args:
            inventory_file (str): The path to the inventory file.
            hostname (str): The hostname to add.
        """
        try:
            # Read Content of file if it exist
            if os.path.exists(os.path.abspath(inventory_file)):
                with open(os.path.abspath(inventory_file), 'r', encoding='utf-8') as file:
                    lines = file.readlines()
            else:
                lines = []
            if lines:
                # Check if the hostname is already in the file
                if any(hostname in line for line in lines):
                    logger.info("Hostname '%s' already exists in %s. Skipping addition.", hostname, inventory_file)
                    return
            # Read the config file
            config = commentedconfigparser.CommentedConfigParser(allow_no_value=True)
            config.read(inventory_file, encoding='utf-8')

            # Check if the section exists, otherwise create it
            if not config.has_section(inventory_file):
                config.add_section(inventory_file)

            # Set the hostname under the correct section
            config.set(inventory_file, hostname, None)  # Use None as value since no value is required

            # Write the inventory file
            with open(os.path.abspath(inventory_file), 'w', encoding='utf-8') as configfile:
                config.write(configfile, space_around_delimiters=False)
                configfile.flush()
        except KeyError as e:
            logger.error("inventory_tagging:add_hostname_inventory: "
                         "Error adding hostname %s to inventory file %s. "
                         "Error type: %s. Error message: %s",
                         hostname, inventory_file, type(e), e)
        except (OSError, Exception) as err:  # pylint: disable=W0718
            logger.error("inventory_tagging:add_hostname_inventory: "
                         "Error adding hostname %s to inventory file %s. "
                         "Error type: %s. "
                         "Error message: %s",
                         hostname, inventory_file, type(err), err
                         )

    def update_inventory(self, node_detail: Tuple[str, str, str, str, str, str]) -> None:
        """
        Update the inventory based on the given node details.
        Args:
            node_detail (Tuple[str, str, str, str, str]): A tuple containing the node,
            service tag, hostname, admin IP, CPU, and GPU.
        """
        # Unpack the node_detail tuple
        node, service_tag, hostname, admin_ip, cpu, gpu = node_detail
        if not hostname:
            logger.warning("inventory_tagging:update_inventory: "
                           "hostname is unavailable for node %s; skipping inventory update", node)
            return
        try:
            if os.getcwd() != self.inventory_dir_path:
                os.chdir(self.inventory_dir_path)
        except OSError as err:
            logger.error("inventory_tagging:update_inventory: "
                         "Error changing current working directory to %s.\n"
                         "Error type: %s.\n"
                         "Error message: %s",
                         self.inventory_dir_path, type(err), str(err))
        if cpu:
            inventory_file_name = self.vendors.get("cpu", {}).get(cpu)
            if inventory_file_name:
                self.add_hostname_inventory(inventory_file_name, hostname)
            hostname_ip_str = f"{hostname} ansible_host={admin_ip}"
            self.add_hostname_inventory("compute_hostname_ip", hostname_ip_str)
        if gpu:
            inventory_file_name = self.vendors.get("gpu", {}).get(gpu)
            if inventory_file_name:
                self.add_hostname_inventory(inventory_file_name, hostname)

    def change_inventory_file_permission(self, inventory_files: List[str]) -> None:
        """
        Change the permission of the inventory files to read-only.
        """
        try:
            if os.getcwd() != self.inventory_dir_path:
                os.chdir(self.inventory_dir_path)
        except OSError as err:
            logger.error("Error changing directory to %s: %s", self.inventory_dir_path, err)
        for inventory_file in inventory_files:
            try:
                os.chmod(inventory_file, 0o444)
            except OSError as err:
                logger.error("Error changing file permission to read-only for %s: %s",
                             inventory_file, err)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Inventory Manager Configuration")
    parser.add_argument('--inventory_files', type=json.loads, help='List of inventory files.')
    parser.add_argument('--vendors', type=json.loads, help='Vendors configuration.')
    parser.add_argument('--inventory_dir_location', type=str, help='Directory path.')
    parser.add_argument('--db_path', type=str, help='Path to the database files.')
    args = parser.parse_args()

    manager = InventoryManager(
        inventory_filenames=args.inventory_files,
        vendors=args.vendors,
        inventory_dir_path=args.inventory_dir_location,
        path_to_db_file=args.db_path
    )
    manager.add_inventory_files()
    node_detail_list = manager.get_cluster_details_db()
    for info in node_detail_list:
        manager.update_inventory(info)
    manager.change_inventory_file_permission(manager.inventory_filenames)
